#!/usr/bin/env bash
# Universal .git/hooks/prepare-commit-msg

# $1 is the path to the commit message file
# $2 is the type of commit

# Set default values for LLM hook environment variables
LLM_GITHOOK_SPINNER_STYLE=${LLM_GITHOOK_SPINNER_STYLE:-classic}
LLM_GITHOOK_FPS=${LLM_GITHOOK_FPS:-30}
LLM_GITHOOK_STATUS_TEXT=${LLM_GITHOOK_STATUS_TEXT:-"Generating commit message..."}
LLM_GITHOOK_SHIMMER_SWEEP_SECONDS=${LLM_GITHOOK_SHIMMER_SWEEP_SECONDS:-2.0}
LLM_GITHOOK_SHIMMER_PADDING=${LLM_GITHOOK_SHIMMER_PADDING:-10}
LLM_GITHOOK_SHIMMER_BAND_WIDTH=${LLM_GITHOOK_SHIMMER_BAND_WIDTH:-5.0}

# Color configuration for shimmer animation and spinner
# Shimmer base color: bright default text color (256-color: 0-255, or TrueColor: "R,G,B")
LLM_GITHOOK_SHIMMER_BASE_COLOR=${LLM_GITHOOK_SHIMMER_BASE_COLOR:-255}
# Shimmer highlight color: dim "wave" that sweeps across (256-color: 0-255, or TrueColor: "R,G,B")
LLM_GITHOOK_SHIMMER_HIGHLIGHT_COLOR=${LLM_GITHOOK_SHIMMER_HIGHLIGHT_COLOR:-240}
# Spinner color: defaults to match shimmer base color for visual consistency
# Accepts: named (red/green/yellow/blue/magenta/cyan/white), 256-color, or TrueColor "R,G,B"
LLM_GITHOOK_SPINNER_COLOR=${LLM_GITHOOK_SPINNER_COLOR:-$LLM_GITHOOK_SHIMMER_BASE_COLOR}
# Color mode: "256" for 256-color palette, "truecolor" for 24-bit RGB
LLM_GITHOOK_COLOR_MODE=${LLM_GITHOOK_COLOR_MODE:-256}

# Skip LLM processing if we're amending AND bypass is allowed (default)
if [ "$2" = "commit" ] && git rev-parse --verify HEAD^{commit} >/dev/null 2>&1 && [ -z "$LLM_GITHOOK_NO_BYPASS_AMENDING" ]; then
    # We're amending - exit without modifying the message
    exit 0
fi

# Force UTF-8 environment (critical for Windows)
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
export PYTHONIOENCODING=utf-8  # If using Python-based LLM

# ANSI colors for output formatting
RED=$(printf '\033[31m')
GREEN=$(printf '\033[32m')
YELLOW=$(printf '\033[33m')
BLUE=$(printf '\033[34m')
NC=$(printf '\033[0m')

COMMIT_MSG_FILE=$1  # POSIX-compliant parameter handling

# Skip if environment variable is set
[ -n "$LLM_GITHOOK_SKIP" ] && exit 0

# Skip when not running in an interactive terminal (e.g., non‑TTY callers like CI/agents)
# Allow override with LLM_GITHOOK_FORCE or LLM_GITHOOK_ALLOW_NONINTERACTIVE
if [ -z "$LLM_GITHOOK_FORCE" ] && [ -z "$LLM_GITHOOK_ALLOW_NONINTERACTIVE" ]; then
  if [ ! -t 0 ] && [ ! -t 1 ]; then
    exit 0
  fi
fi

# Detect rebase sequences to avoid rewriting historical commit messages
GIT_DIR=${GIT_DIR:-$(git rev-parse --git-dir 2>/dev/null)}
if [ -d "$GIT_DIR/rebase-apply" ] || [ -d "$GIT_DIR/rebase-merge" ]; then
  exit 0
fi

# Exit early for merge commits
if [ "$2" = "merge" ] || [ -f "$GIT_DIR/MERGE_HEAD" ]; then
  exit 0
fi

# Function to check if `llm` is installed (with Windows support)
check_llm() {
  case "$(uname -s)" in
    Linux*|Darwin*) command -v llm >/dev/null 2>&1 ;;
    CYGWIN*|MINGW*|MSYS*) [ -f "$LLM_PROGRAM" ] && return 0 || return 1;;
    *) return 1 ;;
  esac
}

if ! check_llm; then
  printf "%bError: $LLM_PROGRAM command not found%b\n" "$RED" "$NC" >&2
  printf "%bError: llm command not found%b\n" "$RED" "$NC" >&2
  exit 1
fi

if ! [ -f "$LLM_PREPARE_COMMIT_MSG_PROMPT" ]; then
  printf "%bError: $LLM_PREPARE_COMMIT_MSG_PROMPT file not found%b\n" "$RED" "$NC" >&2
  exit 1
fi

# Available spinner styles
SPINNER_STYLES=(
  "classic|/-\\"
  "dots|⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
  "arrows|←↖↑↗→↘↓↙"
  "blocks|▖▘▝▗"
  "pulse|▁▂▃▄▅▆▇█▇▆▅▄▃▂"
  "bouncing|⠁⠂⠄⡀⢀⠠⠐⠈"
  "circle|◐◓◑◒"
  "square|◰◳◲◱"
  "triangle|◴◵◶◷"
  "diamond|◇◈◆"
)

# Function to get spinner characters based on style
get_spinner_chars() {
  local style_name="${1:-classic}"

  for style in "${SPINNER_STYLES[@]}"; do
    if [[ "$style" == "$style_name"* ]]; then
      echo "$style" | cut -d'|' -f2
      return 0
    fi
  done

  # Fallback to classic if style not found
  echo "|/-\\"
}

# Parse color value - returns ANSI escape sequence for foreground color
# Input: color name, 256-color number, or "R,G,B" for TrueColor
# Output: ANSI escape sequence (without \033[ prefix and m suffix)
parse_color() {
  local color="$1"

  # Named colors
  case "$color" in
    black)   echo "30" ; return ;;
    red)     echo "31" ; return ;;
    green)   echo "32" ; return ;;
    yellow)  echo "33" ; return ;;
    blue)    echo "34" ; return ;;
    magenta) echo "35" ; return ;;
    cyan)    echo "36" ; return ;;
    white)   echo "37" ; return ;;
  esac

  # TrueColor RGB format: "R,G,B"
  if [[ "$color" == *,*,* ]]; then
    local r g b
    IFS=',' read -r r g b <<< "$color"
    echo "38;2;$r;$g;$b"
    return
  fi

  # 256-color number
  if [[ "$color" =~ ^[0-9]+$ ]]; then
    echo "38;5;$color"
    return
  fi

  # Fallback to white
  echo "37"
}

# Get ANSI escape code for spinner color
get_spinner_ansi() {
  local color="$LLM_GITHOOK_SPINNER_COLOR"
  local code
  code=$(parse_color "$color")
  printf '\033[%sm' "$code"
}

# Detect the best available high-resolution time source once.
detect_time_provider() {
  if command -v gdate >/dev/null 2>&1; then
    echo "gdate"
    return 0
  fi

  if perl -MTime::HiRes -e 'exit 0' >/dev/null 2>&1; then
    echo "perl"
    return 0
  fi

  if command -v python3 >/dev/null 2>&1; then
    echo "python3"
    return 0
  fi

  echo "date"
}

TIME_PROVIDER="$(detect_time_provider)"

get_time() {
  case "$TIME_PROVIDER" in
    gdate) gdate +%s.%N ;;
    perl) perl -MTime::HiRes=time -e 'printf "%.9f\n", time()' ;;
    python3) python3 - <<'PY'
import time
print(f"{time.time():.9f}")
PY
      ;;
    *) date +%s ;;
  esac
}

# Render shimmer text using 256-color interpolation
render_shimmer_256() {
  local text="$1"
  local now="$2"
  local start="$3"
  local base_color="$LLM_GITHOOK_SHIMMER_BASE_COLOR"
  local highlight_color="$LLM_GITHOOK_SHIMMER_HIGHLIGHT_COLOR"

  printf '%s %s\n' "$now" "$start" | awk \
    -v text="$text" \
    -v sweep="$LLM_GITHOOK_SHIMMER_SWEEP_SECONDS" \
    -v pad="$LLM_GITHOOK_SHIMMER_PADDING" \
    -v width="$LLM_GITHOOK_SHIMMER_BAND_WIDTH" \
    -v base="$base_color" \
    -v highlight="$highlight_color" '
    {
      now = $1;
      start = $2;
      len = length(text);
      period = len + (pad * 2);

      elapsed = now - start;
      pos_f = (elapsed % sweep) / sweep;
      center = pos_f * period;

      output = "";

      for (i = 0; i < len; i++) {
        i_pos = i + pad;
        dist = i_pos - center;
        if (dist < 0) dist = -dist;

        intensity = 0.0;
        if (dist <= width) {
          x = 3.14159 * (dist / width);
          intensity = 0.5 * (1.0 + cos(x));
        }

        # Interpolate between base and highlight colors
        color_val = int(base + (intensity * (highlight - base)));
        if (color_val > 255) color_val = 255;
        if (color_val < 0) color_val = 0;

        output = output sprintf("\033[38;5;%dm%s", color_val, substr(text, i+1, 1));
      }

      output = output "\033[0m";
      print output;
    }'
}

# Render shimmer text using TrueColor (24-bit RGB) interpolation
render_shimmer_truecolor() {
  local text="$1"
  local now="$2"
  local start="$3"
  local base_color="$LLM_GITHOOK_SHIMMER_BASE_COLOR"
  local highlight_color="$LLM_GITHOOK_SHIMMER_HIGHLIGHT_COLOR"

  # Parse RGB values from "R,G,B" format or convert 256-color to approximate RGB
  local base_r base_g base_b
  local highlight_r highlight_g highlight_b

  if [[ "$base_color" == *,*,* ]]; then
    IFS=',' read -r base_r base_g base_b <<< "$base_color"
  else
    # Convert 256-color grayscale to RGB
    if [[ "$base_color" -ge 232 && "$base_color" -le 255 ]]; then
      local gray_val=$(( (base_color - 232) * 10 + 8 ))
      base_r=$gray_val; base_g=$gray_val; base_b=$gray_val
    else
      base_r=128; base_g=128; base_b=128
    fi
  fi

  if [[ "$highlight_color" == *,*,* ]]; then
    IFS=',' read -r highlight_r highlight_g highlight_b <<< "$highlight_color"
  else
    if [[ "$highlight_color" -ge 232 && "$highlight_color" -le 255 ]]; then
      local gray_val=$(( (highlight_color - 232) * 10 + 8 ))
      highlight_r=$gray_val; highlight_g=$gray_val; highlight_b=$gray_val
    else
      highlight_r=255; highlight_g=255; highlight_b=255
    fi
  fi

  printf '%s %s\n' "$now" "$start" | awk \
    -v text="$text" \
    -v sweep="$LLM_GITHOOK_SHIMMER_SWEEP_SECONDS" \
    -v pad="$LLM_GITHOOK_SHIMMER_PADDING" \
    -v width="$LLM_GITHOOK_SHIMMER_BAND_WIDTH" \
    -v base_r="$base_r" -v base_g="$base_g" -v base_b="$base_b" \
    -v hi_r="$highlight_r" -v hi_g="$highlight_g" -v hi_b="$highlight_b" '
    {
      now = $1;
      start = $2;
      len = length(text);
      period = len + (pad * 2);

      elapsed = now - start;
      pos_f = (elapsed % sweep) / sweep;
      center = pos_f * period;

      output = "";

      for (i = 0; i < len; i++) {
        i_pos = i + pad;
        dist = i_pos - center;
        if (dist < 0) dist = -dist;

        intensity = 0.0;
        if (dist <= width) {
          x = 3.14159 * (dist / width);
          intensity = 0.5 * (1.0 + cos(x));
        }

        # Linear interpolation between base and highlight RGB
        r = int(base_r + (intensity * (hi_r - base_r)));
        g = int(base_g + (intensity * (hi_g - base_g)));
        b = int(base_b + (intensity * (hi_b - base_b)));

        # Clamp values
        if (r > 255) r = 255; if (r < 0) r = 0;
        if (g > 255) g = 255; if (g < 0) g = 0;
        if (b > 255) b = 255; if (b < 0) b = 0;

        output = output sprintf("\033[38;2;%d;%d;%dm%s", r, g, b, substr(text, i+1, 1));
      }

      output = output "\033[0m";
      print output;
    }'
}

# Main shimmer render function - dispatches to appropriate renderer based on color mode
render_shimmer_text() {
  local text="$1"
  local now="$2"
  local start="$3"

  if [[ "$LLM_GITHOOK_COLOR_MODE" == "truecolor" ]]; then
    render_shimmer_truecolor "$text" "$now" "$start"
  else
    render_shimmer_256 "$text" "$now" "$start"
  fi
}

# Function to show a spinner while fetching LLM response
spinner() {
  local style="${LLM_GITHOOK_SPINNER_STYLE:-classic}"
  local spinner_chars=$(get_spinner_chars "$style")
  local -a spinner_frames=()

  # Unicode-safe spinner frames: split into one character per frame when possible.
  # Bash substring operations are byte-based and will break multi-byte glyphs (e.g., braille dots).
  if command -v python3 >/dev/null 2>&1; then
    while IFS= read -r _frame; do
      spinner_frames+=("$_frame")
    done < <(SPINNER_CHARS="$spinner_chars" python3 - <<'PY'
import os, sys
s = os.environ.get("SPINNER_CHARS", "")
for ch in s:
    sys.stdout.write(ch + "\n")
PY
    )
  fi
  if [ "${#spinner_frames[@]}" -eq 0 ]; then
    local j
    for ((j = 0; j < ${#spinner_chars}; j++)); do
      spinner_frames+=("${spinner_chars:j:1}")
    done
  fi

  local start_time
  start_time="$(get_time)"

  # Frame pacing: default 30 FPS, overridable via LLM_GITHOOK_FPS.
  # Sleep granularity varies by platform, but this keeps the hook from spinning too fast.
  local fps="${LLM_GITHOOK_FPS:-30}"
  local frame_interval
  frame_interval="$(awk -v fps="$fps" 'BEGIN{ if (fps <= 0) fps = 30; printf "%.6f", (1.0 / fps) }')"

  local i=0

  # Get spinner color ANSI code (computed once outside the loop)
  local spinner_ansi
  spinner_ansi=$(get_spinner_ansi)

  while :; do
    local char="${spinner_frames[i]}"
    local now
    now="$(get_time)"
    local shimmered
    shimmered="$(render_shimmer_text "$LLM_GITHOOK_STATUS_TEXT" "$now" "$start_time")"

    # Clear the line and redraw in-place with configurable spinner color.
    printf "\r\033[K%s%s%b %s" "$spinner_ansi" "$char" "$NC" "$shimmered"

    ((i = (i + 1) % ${#spinner_frames[@]}))
    sleep "$frame_interval"
  done
}

# Hide cursor to prevent blinking while fetching response
hide_cursor() { printf '\033[?25l'; }
show_cursor() { printf '\033[?25h'; }

# Start spinner in the background
hide_cursor
spinner 2>/dev/null &
SPIN_PID=$!

# Ensure the spinner and cursor are restored on exit
cleanup() {
  if [ -n "${SPIN_PID:-}" ] && kill -0 "$SPIN_PID" 2>/dev/null; then
    kill "$SPIN_PID" 2>/dev/null || true
    wait "$SPIN_PID" 2>/dev/null || true
  fi
  show_cursor
  printf "\r\033[K"
}
trap cleanup EXIT

# Cache files for last commit message
CACHE_DIR="$HOME/.cache/git-llm-prepare-commit-msg"
CACHE_MD5_FILE="$CACHE_DIR/last_md5"
CACHE_MSG_FILE="$CACHE_DIR/last_message"

# Create cache directory
mkdir -p "$CACHE_DIR"

# Function to calculate MD5 for staged changes
get_staged_md5() {
  # Get the diff content and file list
  local diff_content=$(git diff --staged --no-color --ignore-all-space --diff-algorithm=minimal)
  local files_list=$(git diff --staged --name-only | sort | tr '\n' ' ')

  # If nothing is staged (common when amending only the message), use the current commit contents
  if [ -z "$diff_content$files_list" ] && git rev-parse --verify HEAD^{commit} >/dev/null 2>&1; then
    diff_content=$(git show --no-color --ignore-all-space --diff-algorithm=minimal HEAD)
    files_list=$(git show --name-only --pretty=format: HEAD | sort | tr '\n' ' ')
  fi

  # Create MD5 hash of diff content and file list (GNU coreutils or macOS).
  if command -v md5sum >/dev/null 2>&1; then
    echo -n "$diff_content$files_list" | md5sum | cut -d' ' -f1
  else
    echo -n "$diff_content$files_list" | md5 -q
  fi
}

# Check if we should force regeneration
if [ -n "$LLM_GITHOOK_FORCE" ]; then
  printf "%bForcing commit message regeneration...%b\n" "$YELLOW" "$NC"
  REGENERATE=true
else
  # Check if we have cached commit message
  CURRENT_MD5=$(get_staged_md5)
  if [ -f "$CACHE_MD5_FILE" ] && [ -f "$CACHE_MSG_FILE" ]; then
    CACHED_MD5=$(cat "$CACHE_MD5_FILE")
    CACHED_MSG=$(cat "$CACHE_MSG_FILE")

    # Check if staged changes match cached
    if [ "$CURRENT_MD5" = "$CACHED_MD5" ]; then
      MSG="$CACHED_MSG"
      printf "%bUsing cached commit message...%b\n" "$YELLOW" "$NC"
      REGENERATE=false
    else
      REGENERATE=true
    fi
  else
    REGENERATE=true
  fi
fi

if [ "$REGENERATE" = true ]; then
  # Fetch staged diff content
  DIFF_CONTENT=$(git diff --staged --no-color --ignore-all-space --diff-algorithm=minimal)

  # If nothing is staged (e.g., amend message only), fall back to current commit content
  if [ -z "$DIFF_CONTENT" ] && git rev-parse --verify HEAD^{commit} >/dev/null 2>&1; then
    DIFF_CONTENT=$(git show --no-color --ignore-all-space --diff-algorithm=minimal HEAD)
  fi

  # Check if the 'commit-msg' template exists, create if missing
  if ! $LLM_PROGRAM templates show commit-msg &> /dev/null; then
    $LLM_PROGRAM -s "$(cat $LLM_PREPARE_COMMIT_MSG_PROMPT)" --save commit-msg
  fi

  # Generate commit message with LLM
  if ! MSG=$(echo "$DIFF_CONTENT" | $LLM_PROGRAM -t commit-msg | iconv -c -f UTF-8 -t UTF-8 2>&1); then
    printf "\n%bError: 'llm' command failed to generate the commit message:\n%b%s%b\n\nManually set the commit message.\n" "$RED" "$NC" "$MSG" "$NC"
    exit 1
  fi

  # Cache the generated message and MD5
  echo "$CURRENT_MD5" > "$CACHE_MD5_FILE"
  echo "$MSG" > "$CACHE_MSG_FILE"
fi

# Stop spinner and restore cursor
cleanup

# Display generated commit message
printf "\r\033[K"
printf "%bGenerated commit message:%b\n" "$GREEN" "$NC"
printf "%b%s%b\n\n" "$YELLOW" "$MSG" "$NC"

# Strict model name mapping without explanations
map_llm_model_name() {
    case $1 in
        "deepseek-chat") echo "deepseek-v3.2" ;;
        "deepseek-reasoner") echo "deepseek-r1" ;;
        *) echo "$1" ;;  # Fallthrough for unmapped names
    esac
}

# Get user email from git config and AI model info
USER_EMAIL=$(git config --global --get user.email)
AI_MODEL=$(map_llm_model_name "$(llm models default 2>/dev/null || echo "AI")")

# Write output to commit message file with signed-off-by and co-authored-by footers
{
  echo "$MSG"
  echo ""
  echo "Signed-off-by: $USER_EMAIL"
  echo "Co-Authored-By: $AI_MODEL <noreply@$AI_MODEL>"
} > "$COMMIT_MSG_FILE"
